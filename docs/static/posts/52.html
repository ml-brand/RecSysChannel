<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Рекомендательная [RecSys Channel] — пост #52</title>
  <meta name="description" content=" Recommender Systems with Generative Retrieval    Современные модели для генерации кандидатов обычно строят так: обучают энкодеры (матричные разложения, трансформеры, модели dssm-like) для получения е" />
  <link rel="icon" href="../../favicon.ico" sizes="any" />
  <link rel="icon" type="image/png" sizes="32x32" href="../../favicon-32.png" />
  <link rel="apple-touch-icon" href="../../apple-touch-icon.png" />

  <link rel="canonical" href="https://ml-brand.github.io/RecSysChannel/static/posts/52.html" />
  <meta property="og:type" content="article" />
  <meta property="og:title" content="Рекомендательная [RecSys Channel] — пост #52" />
  <meta property="og:description" content=" Recommender Systems with Generative Retrieval    Современные модели для генерации кандидатов обычно строят так: обучают энкодеры (матричные разложения, трансформеры, модели dssm-like) для получения е" />
  <meta property="og:image" content="https://ml-brand.github.io/RecSysChannel/assets/media/thumbs/52_480.webp" />
  <meta property="og:image:alt" content="Рекомендательная [RecSys Channel]" />
  <meta property="article:published_time" content="2024-11-22T11:35:58+00:00" />
  <meta property="article:author" content="Рекомендательная [RecSys Channel]" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:image" content="https://ml-brand.github.io/RecSysChannel/assets/media/thumbs/52_480.webp" />
  <link rel="stylesheet" href="../../style.css" />
  <script src="../../metrika.js"></script>
</head>
<body data-index-href="../page-3.html">
  <header class="header">
    <div class="container">
      <div class="title-grid single-title">
        <a class="grid-avatar" href="#" target="_blank" rel="noopener">
          <img id="channelAvatar" class="channel-avatar" src="../../assets/channel_avatar.jpg" alt="Аватар канала"  />
        </a>
        <div class="grid-main">
          <div class="title-head">
            <a class="back-link" href="../page-3.html">← Ко всем постам</a>
            <a class="badge-chip" id="siteTitleWrap" href="#" target="_blank" rel="noopener"><h1 id="siteTitle">Рекомендательная [RecSys Channel]</h1></a>
            <div class="hero-actions">
              <a id="subscribeBtn" class="subscribe-btn" href="https://t.me/+3NrSk0BmQ-QzZTMy" target="_blank" rel="noopener" >Подписаться</a>
              <a class="icon-btn" href="../../post.html?id=52" aria-label="Открыть динамическую страницу поста">↺</a>
              <button id="themeToggle" class="icon-btn" type="button" aria-label="Переключить тему"></button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>

  
  <div id="promoBanner" class="promo-banner" hidden>
    <div class="container promo-inner">
      <span class="promo-text"><a href="https://t.me/addlist/5NH3RoVejEI1MGEy">Подпишись на все наши ML каналы. Они классные, отвечаем!</a></span>
      <button id="promoClose" class="promo-close" type="button" aria-label="Скрыть плашку">×</button>
    </div>
  </div>
  

  <main class="container single-page">
    <article id="postContainer" class="post post-page" data-post-id="52">
      <div class="post-header">
        <div class="right"><span class="post-date" data-iso-date="2024-11-22T11:35:58+00:00">2024-11-22 11:35 UTC</span></div>
      </div>
      <div class="post-body"><strong>Recommender Systems with Generative Retrieval </strong><br><br>Современные модели для генерации кандидатов обычно строят так: обучают энкодеры (матричные разложения, трансформеры, модели dssm-like) для получения ембеддингов запроса (пользователя) и кандидата в одном пространстве. Далее по кандидатам строится ANN-индекс, в котором по ембеддингу запроса ищутся ближайшие по выбранной метрике кандидаты. Авторы <a href="https://arxiv.org/abs/2305.05065" rel="nofollow noopener noreferrer">предлагают отойти</a> от такой схемы и научиться генерировать ID айтемов напрямую моделью, которую они обучают. Для этого предлагают использовать энкодер-декодер трансформенную модель на основе фреймворка T5X. <br><br>Остается вопрос, как закодировать айтемы для использования в трансформерной модели и как научиться напрямую предсказывать ID в декодере? Для этого предлагается использовать наработки из прошлой работы — <a href="https://arxiv.org/abs/2306.08121" rel="nofollow noopener noreferrer">Semantic IDs</a>. Такие ID для описания айтемов обладают следующими свойствами: <br><br>— иерархичность — ID в начале отвечают за общие характеристики, а в конце — за более детальные; <br>— они позволяют описывать новые айтемы, решая проблему cold-start;<br>— при генерации можно использовать сэмплинг с температурой, что позволяет контролировать разнообразие.<br><br>В статье проводят эксперимент на датасете <em>Amazon Product Reviews</em>, состоящий из отзывов пользователей и описания товаров. Авторы используют три категории: <em>Beauty</em>, <em>Sports and Outdoors</em> и <em>Toys and Games</em>. Для валидации и тестирования используют схему leave-one-out, когда последний товар в истории каждого пользователя используется для тестирования, а предпоследний — для валидации. Такой подход много критиковали за возможные лики, но авторы используют его для сравнения с уже существующими результатами бейзлайнов.<br><br>Semantic IDs строили следующим образом: каждый товар описывался строкой из названия, цены, бренда и категории. Полученное предложение кодировали предобученной моделью Sentence-T5, получая эмбеддинг размерности 768. На этих ембеддингах обучали RQ-VAE с размерностями слоев 512, 256, 128, активацией ReLU и внутренним ембеддингом 32. Использовали три кодовые книги (codebooks) размером 256 ембеддингов. Для стабильности обучения их инициализировали центроидами кластеров k-means на первом батче. В результате каждый айтем описывает три ID, каждый из словаря размера 256. Для предотвращения коллизий добавляли еще один ID с порядковым номером.<br><br>Энкодер и декодер — трансформеры из четырёх слоев каждый с шестиголовым аттеншеном размерности 64, ReLU активацией, MLP на 1024 и размерностью входа 128. В словарь токенов добавили 1024 (256 × 4) токенов для кодбуков и 2000 токенов для пользователей. В итоге получилась модель на 13 миллионов параметров. Каждый пример в датасете выглядит так: hash(user_id) % 2000, &lt;semantic_ids_1&gt;, … &lt;semantic_ids_n&gt; -&gt; &lt;semantic_ids_n+1&gt;. Во время инференса метод показывает значительный прирост качества (Recall@5, NDCG) по сравнению с бейзлайнами (SASRec, S3-Rec etc). При этом нужно учитывать, что у предложенной модели намного больше параметров, чем у остальных. <br><br>Авторы проводят ablation study для семантических ID — рассматривают варианты их замены на LSH и случайные ID. В обоих случаях semantic ID дает большой прирост и является важным компонентом подхода. Также проводится анализ возможности модели обобщаться на новые айтемы. Для этого из датасета выкидываются 5% товаров, а на инференсе задают отдельным гиперпараметром долю новых кандидатов в top-k (с совпадающими первыми тремя ID) и сравнивают свою модель с KNN.<br><br>Статья получилась во многом академичной, но она обращает внимание на важное направление, которое сейчас активно развивается. Похожий подход можно использовать для кодирования айтемов для LLM, чем, судя по разговорам на конференции, уже активно занимаются. Также можно отметить, что в статье не раскрывается часть важных вопросов: как добавлять новые айтемы и как переобучать RQ-VAE (в реальных сервисах часто меняется распределение контента), а также хотелось бы увидеть сравнение на более приближенных к реальным датасетах.<br><br><em>@RecSysChannel</em><br>Разбор подготовил <tg-emoji emoji-id="5224192932302565805">❣</tg-emoji> Петр Зайдель<div class="media"><img class="media-img" loading="lazy" src="../../assets/media/thumbs/52_480.webp" srcset="../../assets/media/thumbs/52_480.webp 480w, ../../assets/media/52.jpg 1200w" sizes="(max-width: 768px) 100vw, 800px" alt="" data-post-id="52" data-image-index="0" /></div></div>
      <div class="actions">
        <span>2 657 просмотров · 37 реакций</span>
        <span class="action-links"><a href="https://t.me/RecSysChannel/52" target="_blank" rel="noopener">Открыть в Telegram</a> · <a href="../page-3.html">К списку постов</a> · <a href="./52.html">Ссылка на этот пост</a></span>
      </div>
    </article>

    <div class="pager single-nav">
      <a id="prevPost" class="nav-link" href="./53.html" style="visibility:visible">← Более новый</a>
      <a id="nextPost" class="nav-link" href="./51.html" style="visibility:visible">Более старый →</a>
    </div>
  </main>

  <footer class="footer">
    <div class="container">
      <div class="footer-inner">
        <span>based on <a href="https://github.com/ml-brand/tg-to-gh-pages" target="_blank" rel="noopener">tg-to-gh-pages</a> (created by <a href="https://github.com/ml-brand" target="_blank" rel="noopener">ML Brand</a>)</span>
        <a id="repoLink" href="https://github.com/ml-brand/tg-to-gh-pages" target="_blank" rel="noopener">Do the same with your channel.</a>
        <span class="footer-links">
          static copy ·
          <a href="../../feed.xml" target="_blank" rel="noopener">RSS</a> ·
          <a href="../../atom.xml" target="_blank" rel="noopener">Atom</a>
        </span>
      </div>
    </div>
  </footer>

  <script>
    window.__STATIC_POSTS = [{"id": 52, "media": [{"kind": "photo", "path": "../../assets/media/52.jpg", "thumb": "../../assets/media/thumbs/52_480.webp", "size": 24221, "mime": "image/jpeg", "name": null}]}];
    window.__STATIC_META = {"title": "Рекомендательная [RecSys Channel]", "username": "RecSysChannel", "channel": "RecSysChannel", "last_sync_utc": "2026-02-10T23:25:17Z", "posts_count": 105, "last_seen_message_id": 218, "stats": {"new": 104, "updated": 0, "media_downloaded": 104}, "avatar": "assets/channel_avatar.jpg", "meta_schema_version": "1.0.0", "posts_schema_version": "1.0.0"};
  </script>
  <script src="../../common.js"></script>
  <script src="../../static.js"></script>
</body>
</html>
